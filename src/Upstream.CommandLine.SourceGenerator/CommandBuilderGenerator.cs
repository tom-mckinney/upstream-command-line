using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Upstream.CommandLine.SourceGenerator;

[Generator]
public class CommandBuilderGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new CommandSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        CommandSyntaxReceiver syntaxReceiver = (CommandSyntaxReceiver)context.SyntaxReceiver;

        var sb = new StringBuilder();

        if (syntaxReceiver is not null)
        {
            foreach (var command in syntaxReceiver.CommandClasses)
            {
                var semanticModel = context.Compilation.GetSemanticModel(command.SyntaxTree);
                var declaredSymbol = (INamedTypeSymbol)semanticModel.GetDeclaredSymbol(command);
                var properties = declaredSymbol?.GetMembers()
                    .Where(m => m is IPropertySymbol prop)
                    .ToArray();

                foreach (var prop in properties)
                {
                    foreach (var attribute in prop.GetAttributes())
                    {
                        // var attributeValuesList = new List<NameTypeAndValue>();
                        var constructorParams = attribute.AttributeConstructor.Parameters;

                        // Start with an indexed list of names for mandatory args
                        var argumentNames = constructorParams.Select(x => x.Name).ToArray();

                        var allArguments = attribute.ConstructorArguments
                            // For unnamed args, we get the name from the array we just made
                            .Select((info, index) =>
                                new KeyValuePair<string, TypedConstant>(argumentNames[index], info))
                            // Then we use name + value from the named values
                            .Union(attribute.NamedArguments.Select(x =>
                                new KeyValuePair<string, TypedConstant>(x.Key, x.Value)))
                            .Distinct();


                        if (attribute.AttributeClass?.Name == nameof(ArgumentAttribute))
                        {
                            var argumentTest = new ArgumentAttribute();
                            var argProps = typeof(ArgumentAttribute).GetProperties()
                                .ToDictionary(p => p.Name.ToLower(), p => p);

                            foreach (var arg in allArguments)
                            {
                                if (!argProps.TryGetValue(arg.Key, out var propertyInfo)) continue;
                                
                                propertyInfo.SetValue(argumentTest, arg.Value.Value);
                            }

                            foreach (var argumentProperty in typeof(ArgumentAttribute).GetProperties())
                            {
                                // attribute.ConstructorArguments.FirstOrDefault().
                            }
                        }
                        else if (attribute.AttributeClass?.Name == nameof(OptionAttribute))
                        {
                        }
                    }

                    var attributes = prop.GetAttributes()
                        .FirstOrDefault();
                }

                sb.AppendLine($"Console.WriteLine(\"{command.Identifier.ToString()}\");");
            }
        }

        var source = $$"""
                       // <auto-generated />
                       namespace Upstream.CommandLine
                       {
                            public static class UpstreamCommandLine
                            {
                                public static void AutoWireCommands(this CommandLineApplication app)
                                {
                                    Console.WriteLine("Please work, master");
                                    
                                    {{sb}}
                                }
                            
                                public static void Build()
                                {
                                    Console.WriteLine("Please work, master");
                                    
                                    {{sb}}
                                }
                            }
                       }
                       """;

        SourceText sourceText = SourceText.From(source, Encoding.UTF8);
        context.AddSource("UpstreamCommandLine.Generated.cs", sourceText);
    }

    class CommandSyntaxReceiver : ISyntaxReceiver
    {
        public readonly List<ClassDeclarationSyntax> CommandClasses = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax cds)
            {
                if (cds.AttributeLists
                    .SelectMany(a => a.Attributes)
                    .Any(a => a.Name.ToString() is "Command" or "CommandAttribute"))
                {
                    CommandClasses.Add(cds);
                }
            }
        }
    }
}